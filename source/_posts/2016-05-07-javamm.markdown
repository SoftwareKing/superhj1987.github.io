---
layout: post
title: "Java内存管理"
date: 2016-05-07 14:59:44 +0800
comments: true
categories: 
---

对于一个Java程序员来说，大多数情况下的确是无需对内存的分配、释放做太多考虑，对Jvm也无需有多么深的理解。但是，在写程序的过程中却也往往因为这样而造成了一些不容易察觉到的内存问题，并且在内存问题出现的时候，也不能很快的定位并解决。因此，了解并掌握Java的内存管理才能写出更好的程序，才能更好地优化程序的性能。

<!--more-->

## 一. 背景知识

目前国内外著名的几个大型互联网的语言选型如下所示：

1. Google: c/c++ python java js，不得不提的是Google贡献给java社区的guava包质量非常高。
1. Youtube、豆瓣: python
1. fackbook、yahoo、flickr、新浪：**php**(优化过的php) 
1. 网易、阿里、搜狐: java、php、node.js
1. Twitter: ruby->java,之所以如此就在于与jvm相比，Ruby的runtime是非常慢的。并且ruby的应用比起java还是比较小众的。

可见，虽然最近这些年很多言论都号称java已死或者不久即死，但是Java的语言应用占有率一直居高不下。与高性能的c/c++相比，java具有gc机制，并且没有那让人望而生畏的指针，上手门槛相对较低；而与上手成本更低的php、ruby来说，又比这些脚本语言有性能上的优势(这里暂时忽略fb自己开发的php vm)。

对于Java来说，最终是要依靠字节码运行在jvm上的。目前，常见的jvm有以下几种：

- Sun HotSpot
- BEA Jrockit
- IBM J9
- Dalvik(Android)

其中以HotSpot应用最广泛。目前sun jdk的最新版本已经到了8，但鉴于新版的jdk使用并未普及，因此本文仅仅针对HotSpot虚拟机的jdk6来讲。

## 二. Jvm虚拟机内存简介

### 2.1 Java运行时内存区

对于Java的运行时内存组成，有一部分是线程私有的，一部分是线程公有的。

**线程私用的如下：**

- 程序计数器

	当前线程所执行的字节码的行号指示器

- Java虚拟机栈

	Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧，存储局部变量表、操作栈、动态链接、方法出口等信息。

- 本地方法栈

	Native方法服务。在HotSpot虚拟几种，和虚拟机栈合二为一。

**线程共享的如下：**

- Java堆

	存放对象实例，几乎所有的对象实例都在这里分配内存。

- 方法区
	
	存储已经被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等数据。
	
- 运行时常量池

	方法区的一部分。用于存放编译期生辰的各种字面量和符号引用。
	
- 直接内存

	NIO、Native函数直接分配的堆外内存。DirectBuffer引用也会使用此部分内存。
	
### 2.2 对象访问

Jvm中对于某一对象的访问有两种方式：

1. 通过句柄访问

	![access_object_handler.png](/images/blog_images/access_object_handler.png)

2. 直接指针

	![access_direct.png](/images/blog_images/access_direct.png)

	此种方式也是HotSpot虚拟机采用的方式。
	
### 2.3 内存溢出

在JVM申请内存的过程中，会遇到无法申请到足够内存，从而导致内存溢出的情况。一般有以下几种情况：

- 虚拟机栈和本地方法栈溢出
	- StackOverflowError:线程请求的栈深度大于虚拟机所允许的最大深度(循环递归)
	- OutOfMemoryError: 虚拟机在扩展栈是无法申请到足够的内存空间
-  Java堆溢出: 当创建大量对象并且对象生命周期都很长的情况下，会引发OutOfMemoryError
-  运行时常量区溢出：OutOfMemoryError:PermGen space，这里一个典型的例子就是String的intern方法，当大量字符串使用intern时，会触发此内存溢出
-  方法区溢出：方法区存放Class等元数据信息，如果产生大量的类(使用cglib)，那么就会引发此内存溢出，OutOfMemoryError:PermGen space

## 三. 垃圾收集

### 3.1 理论基础

#### 网站访问慢的原因总结来看，一般有以下几点：

- 内存：垃圾收集占用cpu；放入了太多数据，造成内存泄露(java也是有这种问题的^_^)
- 线程死锁
- I/O速度太慢
- 依赖的其他服务响应太慢
- 复杂的业务逻辑或者算法造成响应的缓慢

其中，垃圾收集对性能的影响一般有以下几个：

- 内存泄露
- 程序暂停
- 程序吞吐量显著下降
- 响应时间变慢

#### 垃圾收集的一些基本概念

- Concurrent Collector:收集的同时可运行其他的工作进程
- Parallel Collector: 使用多CPU进行垃圾收集
- Stop-the-word(STW):收集时必须暂停其他所有的工作进程

#### 吞吐量与访问时间

ToDo

#### GC机制

基本描述如下：

- 找出堆中活着的对象
- 释放死对象占用的资源
- 定期调整活对象的位置

算法一般有以下几种：

- Mark-Sweep-Compact 标记-清除-压缩
- Copying Collector 复制算法

#### Mark-标记





### 3.2 hotspot垃圾收集器分析

### 3.3 调优经验

## 四. Java7、8带来的新特性

Java7带来的内存方面的一个很大的改变就是String常量池从Perm区移动到了Heap中。调用String的intern方法时，如果存在堆中的对象，则会直接保存对象的引用，而不会重新创建对象。

Java8中，取消掉了方法区(永久代)，使用“元空间”替代，元空间只与系统内存相关。此外，java8带来了成熟的G1垃圾回收器。