---
layout: post
title: "Java内存管理"
date: 2016-05-07 14:59:44 +0800
comments: true
categories: 
---

对于一个Java程序员来说，大多数情况下的确是无需对内存的分配、释放做太多考虑，对Jvm也无需有多么深的理解。但是，在写程序的过程中却也往往因为这样而造成了一些不容易察觉到的内存问题，并且在内存问题出现的时候，也不能很快的定位并解决。因此，了解并掌握Java的内存管理才能写出更好的程序，才能更好地优化程序的性能。

<!--more-->

## 一. 背景知识

目前国内外著名的几个大型互联网的语言选型如下所示：

1. Google: c/c++ python java js，不得不提的是Google贡献给java社区的guava包质量非常高。
1. Youtube、豆瓣: python
1. fackbook、yahoo、flickr、新浪：**php**(优化过的php) 
1. 网易、阿里、搜狐: java、php、node.js
1. Twitter: ruby->java,之所以如此就在于与jvm相比，Ruby的runtime是非常慢的。并且ruby的应用比起java还是比较小众的。

可见，虽然最近这些年很多言论都号称java已死或者不久即死，但是Java的语言应用占有率一直居高不下。与高性能的c/c++相比，java具有gc机制，并且没有那让人望而生畏的指针，上手门槛相对较低；而与上手成本更低的php、ruby来说，又比这些脚本语言有性能上的优势(这里暂时忽略fb自己开发的php vm)。

对于Java来说，最终是要依靠字节码运行在jvm上的。目前，常见的jvm有以下几种：

- Sun HotSpot
- BEA Jrockit
- IBM J9
- Dalvik(Android)

其中以HotSpot应用最广泛。目前sun jdk的最新版本已经到了8，但鉴于新版的jdk使用并未普及，因此本文仅仅针对HotSpot虚拟机的jdk6来讲。

## 二. Jvm虚拟机内存简介

### 2.1 Java运行时内存区

对于Java的运行时内存组成，有一部分是线程私有的，另一部分是则线程共享的。

**线程私用的如下：**

- 程序计数器

	当前线程所执行的字节码的行号指示器

- Java虚拟机栈

	Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧，存储局部变量表、操作栈、动态链接、方法出口等信息。

- 本地方法栈

	Native方法服务。在HotSpot虚拟几种，和虚拟机栈合二为一。

**线程共享的如下：**

- Java堆

	存放对象实例，几乎所有的对象实例都在这里分配内存。

- 方法区
	
	存储已经被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等数据。
	
- 运行时常量池

	方法区的一部分。用于存放编译期生辰的各种字面量和符号引用。
	
- 直接内存

	NIO、Native函数直接分配的堆外内存。DirectBuffer引用也会使用此部分内存。
	
### 2.2 对象访问

Jvm中对于某一对象的访问有两种方式：

1. 通过句柄访问

	<image src="/images/blog_images/access_object_handler.png" width="500px"/>


2. 直接指针

	<image src="/images/blog_images/access_direct.png" width="500px"/>

	此种方式也是HotSpot虚拟机采用的方式。
	
### 2.3 内存溢出

在JVM申请内存的过程中，会遇到无法申请到足够内存，从而导致内存溢出的情况。一般有以下几种情况：

- 虚拟机栈和本地方法栈溢出
	- StackOverflowError:线程请求的栈深度大于虚拟机所允许的最大深度(循环递归)
	- OutOfMemoryError: 虚拟机在扩展栈是无法申请到足够的内存空间
-  Java堆溢出: 当创建大量对象并且对象生命周期都很长的情况下，会引发OutOfMemoryError
-  运行时常量区溢出：OutOfMemoryError:PermGen space，这里一个典型的例子就是String的intern方法，当大量字符串使用intern时，会触发此内存溢出
-  方法区溢出：方法区存放Class等元数据信息，如果产生大量的类(使用cglib)，那么就会引发此内存溢出，OutOfMemoryError:PermGen space

## 三. 垃圾收集

### 3.1 理论基础

#### 网站访问慢的原因总结来看，一般有以下几点：

- 内存：垃圾收集占用cpu；放入了太多数据，造成内存泄露(java也是有这种问题的^_^)
- 线程死锁
- I/O速度太慢
- 依赖的其他服务响应太慢
- 复杂的业务逻辑或者算法造成响应的缓慢

其中，垃圾收集对性能的影响一般有以下几个：

- 内存泄露
- 程序暂停
- 程序吞吐量显著下降
- 响应时间变慢

#### 垃圾收集的一些基本概念

- Concurrent Collector:收集的同时可运行其他的工作进程
- Parallel Collector: 使用多CPU进行垃圾收集
- Stop-the-word(STW):收集时必须暂停其他所有的工作进程

#### 吞吐量与响应时间

- 吞吐量是对单位时间内完成的工作量的量度。如：每分钟的 Web 服务器请求数量
- 响应时间是提交请求和返回该请求的响应之间使用的时间。如：访问Web页面花费的时间

吞吐量与访问时间的关系很复杂，有时可能以响应时间为代价而得到较高的吞吐量，而有时候又要以吞吐量为代价得到较好的响应时间。而在其他情况下，一个单独的更改可能对两者都有提高。通常，平均响应时间越短，系统吞吐量越大；平均响应时间越长，系统吞吐量越小；
但是，系统吞吐量越大， 未必平均响应时间越短；因为在某些情况（例如，不增加任何硬件配置）吞吐量的增大，有时会把平均响应时间作为牺牲，来换取一段时间处理更多的请求。

针对于Java的垃圾回收来说，不同的垃圾回收器会不同程度地影响这两个指标。例如：并行的垃圾收集器，其保证的是吞吐量，会在一定程度上牺牲响应时间。而并发的收集器，则主要保证的是请求的响应时间。

一张图可以反映这两者的情况：

<image src="/images/blog_images/res_time_throughoutput.png" width="500px"/>


上图就是吞吐量优先的情况，下图则是响应时间优先。

#### GC机制

对于GC(垃圾回收)的流程的基本描述如下：

- 找出堆中活着的对象
- 释放死对象占用的资源
- 定期调整活对象的位置

GC算法一般有以下几种：

- Mark-Sweep 标记-清除
- Mark-Sweep-Compact 标记-整理
- Copying Collector 复制算法

1. Mark-标记

	从"GC roots"开始扫描(这里的roots包括线程栈、静态常量等)，给能够沿着roots到达的对象标记为"live",最终所有能够到达的对象都被标记为"live",而无法到达的对象则为"dead"。效率和存活对象的数量是线性相关的。
	
2. Sweep-清除

	扫描堆，定位到所有"dead"对象，并清理掉。效率和堆的大小是线性相关的。

3. Compact-压缩

	对于对象的清除，会产生一些内存碎片，这时候就需要对这些内存进行压缩、整理。包括：relocate(将存货的对象移动到一起，从而释放出连续的可用内存)、remap(收集所有的对象引用指向新的对象地址)。效率和存活对象的数量是线性相关的。
	
4. Copy-复制

	将内存分为"from"和"to"两个区域，垃圾回收时，将from区域的存活对象整体复制到to区域中。效率和存活对象的数量是线性相关的。
	
其中，copy对比mark-sweep

1. 内存消耗：copy需要两倍的最大live set内存；mark-sweep则只需要一倍。
2. 效率上：copy与live set成线性相关，效率高；mark-sweep则与堆大小线性相关，效率较低。

#### 分代收集

对于分代收集，有以下几个相关理论

- 分代假设：大部分对象的寿命很短，“朝生夕死”，重点放在对年青代对象的收集，而且年青带通常只占整个空间的一小部分。
- 把年青代里活的很长的对象移动到老年代。
- 只有当老年代满了才去收集。
- 收集效率明显比不分代高。

HotSpot虚拟机的分代收集，分为一个Eden区、两个survivor去以及Old Generation/Tenured区，其中eden以及survivor共同组成New Generatiton/Young space。

<image src="/images/blog_images/hotspot-gc.png" width="300px"/>

- eden区是分配对象的区域。
- survivor是minor/younger gc后存储存活对象的区域。
- Tenured区域存储长时间存活的对象。

#### 典型的jvm收集器组合

- 年青代通常使用copy收集，会stop the world
- 老年代收集一般采用mark-sweep-compact, 有可能会stop the world，也可以是concurrent或者部分concurrent。

### 3.2 hotspot垃圾收集器

<image src="/images/blog_images/hotspot-collector.png" width="400px"/>

上图即为hotspot虚拟机的垃圾收集器组成。

#### Serial收集器

- -XX:+UserSerialGC参数打开此收集器
- client模式下新生代默认的收集器。
- 较长的stop the world时间
- 简单而高效

此收集器的一个工作流程如下如所示：

收集前：

<image src="/images/blog_images/serial_before.png" width="400px"/>

收集后：

<image src="/images/blog_images/serial_after.png" width="400px"/>

#### ParNew收集器

- -XX:+UserParNewGC
- +UseConcuMarkSweepGC时默认开启
- Serial收集器的多线程版本
- 默认线程数与CPU数目相同
- -XX:ParrallelGCThreads指定线程数目

对比serial收集器如下图所示：

<image src="/images/blog_images/parnew.png" width="400px"/>

#### Parallel Scavenge收集器

- 新生代并行收集器
- 采用Copy算法
- 主要关注的是达到可控制的吞吐量，“吞吐量优先”
- -XX:MaxGCPauseMillis -XX:GCTimeRAtion两个参数精确控制吞吐量
- -XX:UseAdaptiveSizePolicy GC自适应调节策略
- Server模式的默认新生代收集器

#### Serial Old收集器

- Serial的老年代版本
- Client模式的默认老年代收集器
- CMS收集器的后备预案，Concurrent Mode Failure时使用
- -XX:+UseSerialGC开启此收集器

#### Parallel Old收集器

- -XX:+UseParallelGC -XX:+UseParallelOldGC启用此收集器
- Parallel Scavenge的老年代版本，使用多线程和"mark-sweep"算法
- 关注点在吞吐量以及CPU资源敏感的场合使用
- 一般使用Parallel Scavenge + Parallel Old可以达到最大吞吐量保证

#### CMS收集器

并发低停顿收集器

- -XX:UseConcMarkSweepGC 开启CMS收集器，(默认使用ParNew作为年轻代收集器，SerialOld作为收集失败的垃圾收集器)
- 以获取最短回收停顿时间为目标的收集器，重视响应速度，希望系统停顿时间最短，会和互联网应用。

四个步骤：

- 初始标记 Stop the world: 只标记GC roots能直接关联到的对象，速度很快。
- 并发标记：进行GC roots tracing，与用户线程并发进行
- 重新标记 Stop the world：修正并发标记期间因程序继续运行导致变动的标记记录
- 并发清除

对比serial old收集器如下图所示：

<image src="/images/blog_images/cms.png" width="400px"/>

cms有以下的缺点：

- cms是唯一不进行compact的垃圾收集器，当cms释放了垃圾对象占用的内存后，它不会把活动对象移动到老年代的一端
- 对CPU资源非常敏感。不会导致线程停顿，但会导致程序变慢，总吞吐量降低。CPU核越多越不明显
- 无法处理浮动垃圾。可能出现“concurrent Mode Failure”失败， 导致另一次full GC ,可以通过调整-CMSInitiatingOccupancyFraction来控制内存占用达到多少时触发gc
- 大量空间碎片。这个可以通过设置-XX:UseCMSCompacAtFullCollection(是否在full gc时开启compact)以及-XX:CMSFullGCsBeforeCompaction(在进行compact前full gc的次数)

#### G1收集器

- 使用的标记-清理算法
- 不会产生碎片
- 可预测的停顿
- 化整为零：将整个Java堆划分为多个大小相等的独立区域

<image src="/images/blog_images/g1.png" width="500px"/>

### 3.3 调优经验

- 打开gc，读懂gc日志：-XX:PrintHeapAtGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps
- 最佳状态： 只有young gc
- 从young gc开始， 尽量给年青代大点的内存， 避免full gc
- 注意survivor大小
- 注意内存墙： 4G~5G

#### GC日志简介

<image src="/images/blog_images/gclog.png" width="500px"/>

- 第一个箭头：35592K->1814K(36288K)，箭头指向的是新生段的内存占用情况； - 第二个箭头：38508K->7792K(520256K)，箭头指向的是回收后的内存占用情况。
- 垃圾收集停顿时间： 0.0336

#### 老年代使用建议

- 从Parallel GC开始 (-XX:+UseParallel[Old]GC)
	- Parallel GC的minor GC时间是最快的， CMS的young gc要比parallel慢， 因为内存碎片
	- 最大的吞吐量
- **确实有必要才改成CMS或G1(for old gen collections)**

#### 开发建议

- 小对象allocate的代价很小，通常10个CPU指令
- 收集掉新对象也非常廉价
- 不用担心活的很短的小对象
- 大对象分配的代价以及初始化的代价很大
- 不同大小的大对象可能导致java堆碎片，尤其是CMS, ParallelGC 或 G1还好
- 尽量避免分配大对象
- 改变数据结构大小
	- 避免改变数组或array backed collections / containers的大小
	- 对象构建（初始化）时显式批量定数组大小
- 改变大小导致不必要的对象分配，可能导致java堆碎片
- 对象池可能潜在的问题
	- 增加了活对象的数量， 可能增加GC时间
 	- 访问（多线程）对象池需要锁， 可能带来可扩展性的问题。 小心过于频繁的对象池访问

## 四. Java7、8带来的一些变化

Java7带来的内存方面的一个很大的改变就是String常量池从Perm区移动到了Heap中。调用String的intern方法时，如果存在堆中的对象，则会直接保存对象的引用，而不会重新创建对象。

Java8中，取消掉了方法区(永久代)，使用“元空间”替代，元空间只与系统内存相关。此外，java8带来了成熟的G1垃圾回收器。